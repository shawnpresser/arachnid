#include "common_afx.h"
#include "m_vec3.h"


//===========================================================================
// MVec3
//===========================================================================
const MVec3		MVec3::Zero(0.0F, 0.0F, 0.0F);

//---------------------------------------------------------------------------
MVec3::MVec3()
{
	_data[0] = 0.0F;
	_data[1] = 0.0F;
	_data[2] = 0.0F;
}

//---------------------------------------------------------------------------
MVec3::MVec3( const MVec3& rhs )
{
	_data[0] = rhs._data[0];
	_data[1] = rhs._data[1];
	_data[2] = rhs._data[2];
}

//---------------------------------------------------------------------------
MVec3::MVec3( PxF32 x, PxF32 y, PxF32 z )
{
	_data[0] = x;
	_data[1] = y;
	_data[2] = z;
}

//---------------------------------------------------------------------------
PxF32
MVec3::MagSq() const
{
	return Dot( *this );
}

//---------------------------------------------------------------------------
PxF32
MVec3::Mag() const
{
	return Sqrt( MagSq() );
}

//---------------------------------------------------------------------------
PxF32
MVec3::Dot( const MVec3& rhs ) const
{
	return (_data[0] * rhs._data[0])
		+ (_data[1] * rhs._data[1])
		+ (_data[2] * rhs._data[2]);
}

//---------------------------------------------------------------------------
MVec3
MVec3::Normalized()
{
	MVec3 v3Ret(*this);
	v3Ret.Normalize();
	return v3Ret;
}

//---------------------------------------------------------------------------
PxF32
MVec3::Normalize()
{
	PxF32 x = GetX();
	PxF32 y = GetY();
	PxF32 z = GetZ();
	PxF32 len = Sqrt(x*x + y*y + z*z);
	if ( len != 0.0F )
	{
		PxF32 invLen = 1.0F/len;
		_data[0] = (x * invLen);
		_data[1] = (y * invLen);
		_data[2] = (z * invLen);
	}
	return len;
}
